import { PaginateResult } from 'mongoose';
import { inject, singleton } from 'tsyringe';

import { RedisService } from '@/services';

import { I{{pascalCase name}} } from './{{kebabCase name}}.model';
import { {{pascalCase name}}Repository } from './{{kebabCase name}}.repository';

@singleton()
export default class {{pascalCase name}}Service {
  constructor(
    @inject({{pascalCase name}}Repository) private readonly {{camelCase name}}Repository: {{pascalCase name}}Repository,
    @inject(RedisService) private readonly redis: RedisService
  ) {}

  private async invalidateListCache() {
    await this.redis.delByPrefix('{{camelCase name}}s:list:');
  }

  async create(data: Partial<I{{pascalCase name}}>): Promise<I{{pascalCase name}}> {
    const created = await this.{{camelCase name}}Repository.create(data);
    await this.invalidateListCache();
    return created;
  }

  async findById(id: string): Promise<I{{pascalCase name}} | null> {
    return this.{{camelCase name}}Repository.findById(id);
  }

  async findAll(query: Record<string, unknown> = {}): Promise<PaginateResult<I{{pascalCase name}}>> {
    if (!this.redis.isConnected) {
      return this.{{camelCase name}}Repository.findAll(query);
    }

    const cacheKey = `{{camelCase name}}s:list:${JSON.stringify(query)}`;
    const cached = await this.redis.get<PaginateResult<I{{pascalCase name}}>>(cacheKey);

    if (cached) {
      return cached;
    }

    const result = await this.{{camelCase name}}Repository.findAll(query);
    await this.redis.set(cacheKey, result, 300);
    return result;
  }

  async update(id: string, data: Partial<I{{pascalCase name}}>): Promise<I{{pascalCase name}} | null> {
    const updated = await this.{{camelCase name}}Repository.updateById(id, data);
    if (updated) {
      await this.invalidateListCache();
    }
    return updated;
  }

  async remove(id: string): Promise<I{{pascalCase name}} | null> {
    const deleted = await this.{{camelCase name}}Repository.deleteById(id);
    if (deleted) {
      await this.invalidateListCache();
    }
    return deleted;
  }

  async softDelete(id: string): Promise<I{{pascalCase name}} | null> {
    const deleted = await this.{{camelCase name}}Repository.softDeleteById(id);
    if (deleted) {
      await this.invalidateListCache();
    }
    return deleted;
  }

  async restore(id: string): Promise<I{{pascalCase name}} | null> {
    const restored = await this.{{camelCase name}}Repository.restoreById(id);
    if (restored) {
      await this.invalidateListCache();
    }
    return restored;
  }
}
